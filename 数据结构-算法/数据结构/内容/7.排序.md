### 插入排序
* #### 直接插入排序
  是稳定的，时间复杂度：O( n<sup>2</sup> )。
  ```js
  function sort(arr) {
    for(int i = 2; i <= arr.length; i++){
      if(arr[i] < arr[i-1]) {
        arr[0] = arr[i]
        for(int j = i-1; arr[0] < arr[j]; j--){
          arr[j+1] = arr[j]
        }
        arr[j+1] = arr[0]
      }
    }
  }
  ```
* #### 希尔排序
  是不稳定的，时间复杂度：O(1)。
  ```js
  ```

### 交换排序
* #### 冒泡排序
  是稳定的，时间复杂度：O(1)。
  ```cpp
  // 第一轮：最小的元素移动到开头，小的往低位，大的往高位。
  void BobbleSort(SeqList R, int n)
  { //采用自底向上扫描数组R[1．．n]做冒泡排序
    int i,j,flag;
    for(i = 1; i < n; i++)
    {
      flag = 0;
      for(j = n; j >= i+1; j--)
      {
        if(R[j].key < R[j-1].key)
        {
          R[0] = R[j-1];
          R[j-1] = R[j];
          R[j] = R[0];
          flag = 1;
        }
      }
      // 没有元素交换，表示已完成排序，即可退出循环。
      if (flag == 0) return;
    }
  }
  ```
* #### 快速排序
是不稳定的，时间复杂度：`O(nlog`<sub>2</sub>`n)`

### 选择排序
* #### 直接选择排序
* #### 堆排序

### 归并排序
* #### 二路归并排序
  是稳定的，时间复杂度：`O(nlog`<sub>2</sub>`n)`


### 分配排序
* #### 箱排序
  是稳定的，时间复杂度：`O(n)`。

  类比洗52张扑克牌，需13个“箱子”。

适用关键字取值范围较小的情况。
* #### 基数排序
  是稳定的，时间复杂度：`O(d*(rd+n))`。`rd`是基数，`d`是关键字的位数，`n`是元素个数。

  是对箱排序的改进和推广。从低位到高位依次对 `k`<sup>j</sup> `(j=d-1,d-2,...,0)` 进行箱排序。
